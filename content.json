[{"title":"前端需要了解的 HTTP 知识","date":"2018-11-04T16:00:00.000Z","path":"2018/11/05/HTTP-related-knowledge/","text":"本篇文章主要是对 HTTP 相关知识做了整理，包括 HTTP 的一些基础概念、HTTP 缓存、HTTPS、HTTP/2 等。 一、基础概念HTTP( HyperText Transfer Protocol， 超文本传输协议 ) 是一种通信协议，它允许将 HTML (超文本标记语言) 文档从 Web 服务器传送到客户端的浏览器。 URLURI 包含 URL 和 URN。 URL（Uniform Resource Locator，统一资源定位符），是使用浏览器访问 Web 页面时需要输入的网页地址。 URN（Uniform Resource Name，统一资源名称） URI（Uniform Resource Identifier，统一资源标识符），URI 用字符串标识某一互联网资源，URN 表示资源的名称，URL表示资源的地址（互联网上所处的位置）。可见 URL、URN 都是 URI 的子集。 URL 基本格式如下： scheme：协议方案名，指定访问资源所使用的协议类型（例如：http，ftp等） host：服务器 IP 地址或域名 port：端口号 path：资源路径 query：查询参数 fragment：片段标识符，即 # 后的 hash 值，一般用来定位到某个位置 HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。 HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。 HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。 请求报文和响应报文的结构 请求报文 请求行：包含请求方法，请求 URI 和 HTTP 版本。 响应报文 状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。 二、HTTP 方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 GET 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 HEAD 获取报文首部。 和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。 POST 传输实体主体 主要用来传输数据，而 GET 主要用来获取资源。 PUT 上传文件。 由于自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的 Web 网站不使用该方法。 PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 OPTIONS 询问支持的方法 查询请求 URI 指定的资源支持的方法。会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT 要求用隧道协议连接代理 CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就减 1，当数值刚好减到 0 时就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 三、HTTP 状态码 服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 原因短语 1XX Informational（提示信息） 接受的请求正在处理 2XX Success（成功） 请求正常处理完毕 3XX Redirection（重定向） 需要进行附加操作以完成请求 4XX Client Error（客户端错误） 服务器无法处理请求 5XX Server Error（服务器错误） 服务器处理请求出错 1XX 提示信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200 OK ：请求成功。 204 No Content ：请求已成功处理，但是返回的响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，而服务器成功执行了这部分 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向。 302 Not Found ：临时性重定向。 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 当返回状态码 301、302、303 时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。 301、302 标准是禁止将 POST 方法改成 GET 方法的，但是实际使用时大家都会这么做。 304 Not Modified ：如果客户端发送一个条件 GET 请求（请求报文首部中包含一些条件，如： If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since），而最近资源未被修改的话，服务器就会返回 304 状态码，此时，响应报文中不包含任何响应主体的部分。 307 Temporary Redirect ：临时重定向。与 302 Found 含义相同，但是 307 会遵照浏览器标准，不会从 POST 变成 GET。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：当前请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。 403 Forbidden ：请求被拒绝。 404 Not Found ：服务器上没有请求的资源。 5XX 服务器错误 500 Internal Server Error ：服务器在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 四、HTTP 首部HTTP 首部字段有 4 种类型：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 五、HTTP 缓存机制前后端的 HTTP 交互中，使用缓存可以很大程度上提升效率，良好的缓存策略可以降低资源的重复加载，提高网页的整体加载速度。 缓存策略通常分为两种：强缓存和协商缓存。 1. 强缓存实现强缓存通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200。 ExpiresExpires: Wed, 22 Oct 2018 08:30:00 GMT Expires 是 HTTP/1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:30:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-ControlCache-Control 常见的指令有：private 、public 、no-cache 、max-age 、no-store，默认为 private。 指令 说明 private 客户端可以缓存 public 客户端和代理服务器都可以缓存 max-age=xxx 缓存的内容将在 xxx 秒后失效 no-cache 需要使用协商缓存来验证缓存数据 no-store 所有内容都不会缓存 Cache-Control 出现于 HTTP/1.1，优先级高于 Expires。 2. 协商缓存如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。 Last-Modified 和 If-Modified-SinceLast-Modified 表示本地文件的最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP/1.1 出现了 ETag。 ETag 和 If-None-MatchETag 类似于文件指纹，If-None-Match 会将 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。 总结对于强缓存，服务器通知浏览器一个缓存时间，如果在缓存时间内，下次请求时直接用缓存。如果不在缓存时间内，则执行协商缓存策略。 对于协商缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。 客户端第一次请求： 客户端再次请求时： 六、HTTPSHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能被篡改。 HTTPS（Hypertext Transfer Protocol Secure，超文本传输安全协议，常称为 HTTP over TLS，HTTP over SSL 或 HTTP Secure）并非是一种新协议，只是 HTTP 通信接口部分用 TLS 协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 TLS 时，则变成先和 TLS 通信，再由 TLS 和 TCP 通信。 TLSTLS 的前身是 SSL（Secure Sockets Layer，安全套接字层），由网景公司开发，后来被 IETF（国际互联网工程任务组） 标准化并改名。通常没有特别说明时，SSL 和 TLS 指的是同一个协议，不做严格区分。 TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要消耗两个 RTT（Round-Trip Time，往返时间），接下来可以通过 Session Resumption 减少到一个 RTT。 在 TLS 中使用了两种加密技术，分别是：对称密钥加密 和 非对称密钥加密。 对称密钥加密对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 非对称密钥加密非对称密钥加密，又称公开密钥加密（Public-Key Encryption），使用一对非对称的密钥。一把叫做公开密钥（public key），另一把叫做私有密钥（private key）。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全的将公开密钥传输给通信发送方； 缺点：运算速度慢。 HTTPS 采用的加密方式HTTPS 采用对称密钥加密和非对称密钥加密两者并用的混合加密机制。在交换密钥环节使用非对称密钥加密来保证传输过程的安全性，之后的建立通信交换报文阶段则使用对称密钥加密方式来保证通信过程的效率。 TLS 握手过程握手阶段涉及四次通信，需要注意的是，握手阶段的所有通信都是明文的。 1. 客户端发出请求（ClientHello）首先，客户端先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。 这一步客户端主要向服务器提供以下信息： （1）支持的协议版本，如 TLS 1.2； （2）一个客户端生成的随机数，稍后用于生成“会话密钥”； （3）支持的加密方法，如 RSA 公钥加密； （4）支持的压缩方法。 2. 服务器回应（ServerHello）服务器收到客户端请求后，向客户端发出回应，叫做 ServerHello 。 服务器的回应包含以下内容： （1）确认使用的加密通信协议版本，如 TLS 1.2。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信； （2）一个服务器生成的随机数，稍后用于生成“会话密钥”； （3）确认使用的加密方法，比如 RSA 公钥加密； （4）服务器证书。 除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供“客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，向正式客户提供的 USB 密钥，里面就包含了一个客户端证书。 3. 客户端回应客户端收到服务器回应后，首先验证服务器证书是否有效。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥，然后向服务器发送以下信息： （1）一个随机数，会用服务器公钥加密以防被窃听； （2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送； （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验。 上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称“pre-master key”。这样客户端和服务器就同时又三个随机数，接着双方就用事先商定的加密方法各自生成本次会话所用的同一把”会话密钥“。 如果上一步服务器要求客户端证书，客户端会在这一步发送证书及相关信息。 4. 服务器的最后回应服务器收到客户端的第三个随机数 pre-master key 后，计算生成本次会话所用的”会话密钥“，然后向客户端发送下面的信息。 （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送； （2）服务器握手结束通知。这一项也是前面发送的所有内容的 hash 值，用来供客户端校验。 到此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就是完全使用普通的 HTTP 协议，只不过用”会话密钥“加密内容。 通过以上步骤可知，在 TLS 握手阶段，两端使用非对称密钥加密的方式来通信，但是因为非对称密钥加密损耗的性能比对称密钥加密大，所以在正式传输数据时，两端使用对称加密的方式通信。 七、HTTP/2.0HTTP/1.x 实现简单是以牺牲性能为代价的： HTTP/1.x 客户端需要使用多个连接才能实现并发和缩短延迟； HTTP/1.x 不会压缩请求和响应头，从而导致不必要的网络流量； HTTP/1.x 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。 HTTP/2.0 相比于 HTTP/1.x，可以说是大幅度提高了 web 的性能。 二进制传输HTTP/2.0 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。HTTP/1.x 协议通过文本的方式传输数据，以换行符作为纯文本的分隔符；而 HTTP/2.0 将传输的信息分割为更小的消息和帧，并采用二进制格式编码。 多路复用在 HTTP/2.0 中，有两个非常重要的概念：帧（frame）和流（stream）。 帧代表最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流，即可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP/1.x 中的队首阻塞问题，极大的提高传输性能。 首部压缩在 HTTP/1.x 中，使用纯文本的形式传输首部，通常会给每个传输增加 500-800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。 为了减少这样的开销和提升性能，HTTP/2.0 使用 HPACK 压缩格式对传输的首部进行编码，减少了首部的大小。并在两端维护了索引表，用于记录出现过的首部，后面在传输过程中就可以传输已经记录过的首部的键名，对端收到数据后就可以通过键名找到对应的值。 服务端推送在 HTTP/2.0 中，服务端可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务端还可以向客户端推送额外资源，而无需客户端明确地请求。 可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采用服务端推送，提前给客户端推动必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下也可以使用prefetch。 八、GET 和 POST 的区别1. 作用GET 用于获取数据，POST 用于提交数据。 2. 参数GET 传递的参数只能以 QueryString 的格式带在 URL 后面，POST 参数存储在实体主体中。 GET /test/demo_form.asp?name1=value1&amp;name2=value2 POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 因为 URL 只支持 ASCII 码，所以 GET 参数中如果存在中文等字符需要先进行编码。POST 参数支持标准字符集。 GET 参数对长度有限制，可以传输的数据量较小。实际上 HTTP 协议对 URL 长度没有限制，限制 URL 长度的大多数是浏览器或服务器的配置参数，一般最好不要超过 IE 的最大长度限制 2083 字节（2K+35）。 POST 可以传输的数据量较大。理论上是没有大小限制的，HTTP 协议规范也没有进行大小限制，但实际上 POST 所能传递的数据量大小取决于服务器的设置和内存大小。 3. 安全这里的「安全」和通常理解的「安全」意义不同，如果一个方法是\b「只读」的，也就是说它不会改变服务器的状态，那么这个方法就是安全的。 GET 方法是安全的，而 POST 不是。因为 POST 的目的是传输实体主体内容，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET，还有 HEAD，OPTIONS。不安全的方法除了 POST，还有 PUT，DELETE。 4. 幂等性幂等的 HTTP 方法，同样的请求执行一次和连续执行多次的效果是一样的，服务器的状态也是一样的。也就是说，幂等方法不应该具有副作用（统计用途除外）。 所有安全方法也都是幂等的。 在正确实现的条件下， GET、HEAD、PUT、DELETE 等方法都是幂等的，而 POST 不是。 引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新是遇到 POST 会给用户提示的原因：POST 不是幂等的，重复发送请求可能会带来意想不到的后果。 5. 可缓存如果要对响应进行缓存，需要满足一下条件： 请求报文的 HTTP 方法本身是可缓存的。GET 和 HEAD 是可缓存的，PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存。 响应报文的状态码是可缓存的。包括：200，203，204，206，300，301，404，405，410，414，501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 总结一下： GET 方法用于获取数据，参数通过 URL 传递、长度有限制，可传输的数据量较小，安全，幂等，可缓存。 POST 方法用于提交数据，参数存储在实体主体中，可传输的数据量取决于服务器设置和内存大小，不安全，不幂等，不可缓存。 参考资料 上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014. 彻底弄懂HTTP缓存机制及原理 SSL/TLS协议运行机制的概述 HTTP/2 简介 | Web | Google Developers URL最大长度问题","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://zouyang0921.com/tags/HTTP/"},{"name":"笔记","slug":"笔记","permalink":"http://zouyang0921.com/tags/笔记/"}]},{"title":"JavaScript 模块化","date":"2018-08-13T16:00:00.000Z","path":"2018/08/14/javascript-modularity/","text":"随着 JavaScript 日新月异的发展，超过了它产生时候的自我定位，由于没有模块管理的概念，在做大型项目或文件组织的时候，就会异常纠结，而且后续也很难维护，长此以往，模块化是必然趋势~ 模块化的主要特征是: 可复用 封装了变量和函数，和全局的 namaspace 不接触，松耦合 只暴露可用的 public 方法，其它私有方法全部隐藏 目前比较流行的 JS 模块化规范有 CommonJS、AMD、CMD、UMD 以及 ES6 的模块化。 CommonJSNode.js 是 CommonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，通过 module.exports 导出对外的变量或接口，通过 require 导入其它模块的输出到当前的模块的作用域中。 模块定义// 定义模块 math.js var basicNum = 0; function add(a, b) { return a + b; } module.exports = { // 在这里写需要向外暴露的变量或函数 basicNum: basicNum, add: add }; 模块引用// 引入自定义的模块，参数需要包含路径，可省略后缀.js var math = require(&#39;./math); math.add(3, 5); // 引入核心模块，参数直接写模块名，不需要包含路径 var http = require(&#39;http&#39;); http.createServer(...).listen(8080); module.exports v.s. exports很多时候，我们会看到在一个模块中有两种方式来输出变量： 方式一：对 module.exports 赋值 // hello.js function sayHello() { console.log(&#39;Hello&#39;); } function sayGoodbye() { console.log(&#39;Goodbye&#39;); } module.exports = { sayHello: sayHello, sayGoodbye: sayGoodbye }; 方式二：直接使用 exports // hello.js function sayHello() { console.log(&#39;Hello&#39;); } function sayGoodbye() { console.log(&#39;Goodbye&#39;); } exports.sayHello = sayHello; exports.sayGoodbye = sayGoodbye; 但是，不可以直接对 exports 赋值。 // 代码可以执行，但是并没有输出任何变量 exports = { sayHello: sayHello, sayGoodbye: sayGoodbye }; 原因是什么呢？我们来分析一下 Node.js 的加载机制。 首先，Node.js 会把待加载的文件 hello.js 放入一个包装函数 load() 中执行。在执行 load() 函数前，Node.js 准备好了 module 变量： var module = { id: &#39;hello&#39;, exports: {} }; load() 函数最终返回 module.exports： var load = function(module) { // hello.js 文件的内容 ... // load 函数返回 return module.exports; }; var exports = load(module); 也就是说，exports 实际上是 module.exports 的引用，或者理解为 exports 是一个指针，指向 module.exports ，所以在使用 exports 的时候，只能是 exports.sayHello = function() {...} 这样的方式，而不能使用 exports = { sayHello: function() {}} 这种方式相当于重新定义了 exports，module.exports 仍然是空对象 {}，所以给 exports 赋值是无效的。 优点：解决了依赖、全局变量污染的问题。 缺点：CommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 AMDAMD( Asynchronous Module Definition ) 是 Require.js 在推广过程中对模块定义的规范化产出。 AMD 规范采用异步方式加载模块，所有依赖这个模块的语句都定义在一个回调函数中，等到加载完成后，这个回调函数才会执行。 实现 AMD 规范的模块化通过 define() 方法将代码定义为模块，通过 require() 方法实现模块的加载。 这里以 require.js 为例，首先将 require.js 引入到页面中： &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; 定义模块（1）独立模块 即 不需要依赖任何其他模块 // math.js define(function() { var basicNum = 0; var add = function(a, b) { return a + b; }; return { basicNum: basicNum, add: add }; }); （2）非独立模块 即 需要依赖其他模块 define([&#39;underscore&#39;], function(_) { var classify = function(list) { _.countBy(list, function(num) { return num &gt; 30 ? &#39;old&#39; : &#39;young&#39;; }); }; return { classify: classify }; }); 引用模块require([&#39;jquery&#39;, &#39;math&#39;], function($, math) { var sum = math.add(3, 5); $(&#39;#sum&#39;).html(sum); }); require.js 还提供了一个 API： require.config() ，可以用来配置项目中用到的基础模块。 // 通过 config() 指定各模块路径和引用名 require.config({ baseUrl: &#39;js/lib&#39;, paths: { &#39;jquery&#39;: &#39;jquery.min&#39;, // 实际路径为 js/lib/jquery.min.js &#39;underscore&#39;: &#39;underscore.min&#39; } }); // 引入模块 require([&#39;jquery&#39;, &#39;underscore&#39;]， function($, _) { ... }); 优点：适合在浏览器环境中异步加载模块，可以并行加载多个模块。 缺点：不能按需加载，开发成本大。 CMDCMD( Common Module Definition ) 是 Sea.js 在推广过程中对模块定义的规范化产出。 AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。 // AMD 写法 define([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], function(a, b, c, d, e) { // 等于在最前面声明并初始化了所有依赖的模块 a.doSomething(); if (false) { // 即使没有用到某个模块 b，但 b 还是提前执行了 b.doSomething(); } }); // CMD 写法 define(function(require, exports, module) { var a = require(&#39;./a); // 在需要时声明 a.doSomething(); if (false) { var b = require(&#39;./b); b.doSomething(); } }); UMDUMD ( Universal Module Definition )，希望提供一个前后端跨平台的解决方案(支持 AMD 与 CommonJS 模块方式)。 UMD 的实现原理： 先判断是否支持 Node.js 模块格式( exports 是否存在 )，存在则使用 Node.js 模块格式。 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。 前两个都不存在，则将模块公开到全局( window 或 global )。 下面是一个示例： eventUtil.js (function(root, factory) { if (typef exports === &#39;object&#39;) { module.exports = factory(); } else if (typeof define === &#39;function&#39; &amp;&amp; define.amd) { define(factory); } else { root.eventUtil = factory(); } })(this, function() { // module return { addEvent: function(el, type, handle) { // ... }, removeEvent: function(el, type, handle) { // ... } }; }); ES6 Module在 ES6 中， 我们可以通过 import 引入模块，通过 export 导出模块，功能比前几个方案更强大，也是我们推荐使用的，但是由于浏览器对 ES6 的支持程度不同，目前都是使用 babel 或 traceur 把 ES6 代码转化为 ES5 代码，然后再在浏览器环境中执行。 // 定义模块 math.js var basicNum = 0; var add = function(a, b) { return a + b; }; export { basicNum, add }; // 引用模块 import { basicNum, add } from &#39;./math&#39;; function test(element) { element.textContent = add(basicNum, 99); } test(); 导出模块时还可以用 export default ，为模块指定默认输出，对应的 import 语句不需要使用大括号。 // 输出模块 export default { basicNum, add } // 引入模块 import math from &#39;./math&#39;; 注：一个模块只能有一个 export default。 CommonJS 与 ES6 模块化的差异1. CommonJS 支持动态导入，也就是 require(${path}/xx.js) ，ES6 目前还不支持，但是已有提案。 2. CommonJS 是同步导入，ES6是异步导入。 CommonJS 因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。 ES6 因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响。 3. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值；另一方面，如果导出的值变了，导入的值也不会变，所以如果想更新值，必须重新导入一次。 ES6 采用实时绑定的方式，导入和导出的值都指向同一个内存地址，所以导入的值会跟随导出的值变化。 4. CommonJS 模块是运行时加载，ES6 模块是编译时加载。 CommonJS 模块就是一个对象，在导入时先加载整个模块，生成一个对象( 这个对象只有在脚本运行完才会生成 )，然后再从这个对象上读取方法，这种加载称为“运行时加载”。 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码运行之前( 即编译时 )的静态解析阶段就完成了模块加载，比 CommonJS 模块的加载方式更高效。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"从 Event Loop 谈 JavaScript 的执行机制","date":"2018-07-21T16:00:00.000Z","path":"2018/07/22/javascript-execution-mechanism/","text":"在上一篇文章 从进程和线程了解浏览器的工作原理 中，我们已经了解了浏览器的渲染流程，浏览器初次渲染完成后，接下来就是 JS 逻辑处理了。这篇文章我们结合 event loop 来了解一下 JavaScript 代码是如何执行的。 浏览器环境下 JS 引擎的事件循环机制在 上一篇文章 中我们已经知道了 JavaScript 是单线程的，这意味着 JavaScript 只有一个主线程来处理所有的任务。所以，所有任务都需要排队执行，上一个任务结束，才会执行下一个。如果上一个任务耗时很长，那么下一个任务也要一直等着。 排队通常由两种原因造成： 任务计算量过大，CPU 处理不过来； 执行任务需要的东西没有准备好（如 Ajax 获取到数据才能往下执行），所以无法继续执行，只好等待 IO 设备（输入输出设备），而 CPU 却是闲着的。 JavaScript 的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务，等到 IO 设备返回了结果，再把挂起的任务继续执行下去。 于是，任务可以分为两种： 同步任务：在主线程上排队执行的任务。只有上一个任务执行完，才能执行下一个任务； 异步任务：不进入主线程、而进入任务队列（task queue）的任务。只有任务队列通知主线程某个异步任务可以执行了，该任务才会进入主线程执行。 JavaScript 执行的过程如下： 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外还存在一个任务队列。当遇到一个异步任务时，并不会一直等待其返回结果，而是会将这个异步任务挂起，继续执行执行栈中的其他任务。当一个异步任务返回结果后，就会在任务队列中放置一个事件。 被放入任务队列的事件不会立刻执行其回调，而是等待执行栈中的所有同步任务都执行完毕，主线程处于闲置状态时，主线程就会读取任务队列，看里面是否有事件。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，开始执行。 只要执行栈空了，就会去读取任务队列，主线程从任务队列中读取事件的过程是循环不断的，这种执行机制称为事件循环（event loop）。 这里引用 Philip Roberts的演讲《Help, I’m stuck in an event-loop》中的一张图来协助理解： 图中的 stack 表示我们所说的执行栈，WebAPIs代表一些异步任务，callback queue 则是任务队列。 定时器任务队列除了放置异步任务的事件，还可以放置定时事件，即指定某些代码在多长时间后执行。 定时器功能主要有 setTimeout() 和 setInterval() 这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码只执行一次，后者为反复执行。这里我们主要讨论 setTimeout() 。 setTimeout(function() { console.log(&#39;hello&#39;); }, 3000) 上面这段代码，3000 毫秒后会将该定时事件放入任务队列中，等待主线程执行。 如果将延迟时间设为 0，就表示当前代码执行完（执行栈清空）以后，立刻执行指定的回调函数。 setTimeout(function() { console.log(1); }, 0); console.log(2); 上面代码的执行结果总是： 2 1 因为只有在执行完第二个console.log以后，才会去执行任务队列中的回调函数。 注意： setTimeout(fn, 0)的含义是：指定某个任务在主线程最早可得的空闲时间执行。 虽然代码的本意是 0 毫秒后就将事件放入任务队列，但是 W3C 在 HTML 标准中规定，setTimeout() 的延迟时间不能低于 4 毫秒。 setTimeout() 只是将事件插入了任务队列，必须要等到执行栈执行完毕，主线程才会去执行它指定的回调函数。如果当前代码耗时很长，那这个事件就得一直等待，所以并没有办法保证回调函数一定会在setTimeout() 指定的时间执行。 macro task 与 micro task前面我们已经将 JavaScript 事件循环机制梳理了一遍，在 ES5 中是够用了，但是在 ES6 中仍然会遇到一些问题，比如下面这段代码： setTimeout(function() { console.log(&#39;setTimeout&#39;); }, 0); new Promise(function(resolve) { console.log(&#39;Promise1&#39;); for (var i=0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(&#39;Promise2&#39;); }).then(function() { console.log(&#39;then&#39;); }); console.log(&#39;end&#39;); 它的结果是： Promise1 Promise2 end then setTimeout 为什么呢？这里就需要解释一个新的概念：macro-task 和 micro-task。 除了广义的同步任务和异步任务的划分，对任务还有更精细的定义： macro-task（宏任务）：可以理解为每次执行栈执行的代码就是一个宏任务，包括每次从任务队列中获取一个事件并将其对应的回调放入到执行栈中执行。宏任务需要多次事件循环才能执行完，任务队列中的每一个事件都是一个宏任务。每次事件循环都会调入一个宏任务，浏览器为了能够使 JS 内部宏任务与 DOM 任务有序的执行，会在一个宏任务结束后，下一个宏任务开始前，对页面进行重新渲染。 micro-task（微任务）：可以理解为在当前宏任务执行结束后立即执行的任务。微任务是一次性执行完的，在一个宏任务执行完毕后，就会将它执行期间产生的所有微任务都执行完毕。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务放到队列尾部，之后会依次执行。 形成 macro-task 或 micro-task 的场景： macro-task：script（整体代码），setTimeout，setInterval，setImmediate，I/O，UI 渲染等 micro-task：process.nextTick，Promise（这里指浏览器实现的原生 Promise），Object.observe，MutationObserver 宏任务和微任务执行的顺序如下： 现在我们再来看看上面那段代码是怎么执行的： 整个 script 代码，放在了macro-task 队列中，取出来放入执行栈开始执行； 遇到 setTimeout，加入到 macro-task 队列； 遇到 Promise.then，放入到另一个队列 micro-task 队列； 等执行栈执行完后，下一步该取出 micro-task 队列中的任务了，在这里也就是 Promise.then； 等到 micro-task 队列都执行完后，然后再去取出 macro-task 队列中的setTimeout。 Node.js 中的 Event Loop在 Node.js 中，事件循环表现出的状态与浏览器中大致相同。不同的是Node.js 中有一套自己的模型，它是通过 libuv 引擎来实现事件循环的。 下面我们来看看 Node.js 是如何执行的？ Node.js 是 使用 V8 引擎作为 JS 解释器，V8 引擎将 JS 代码解析后去调用Node API； 这些 API 由 libuv 引擎驱动，执行对应的任务。libuv 引擎将不同的任务分配给不同的线程，形成一个事件循环（event loop），以异步的方式将任务的执行结果返回给 V8 引擎； V8 引擎再将结果返回给用户。 事件循环模型下面是一个 libuv 引擎中的事件循环的模型： ┌───────────────────────┐ ┌─&gt;│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │&lt;─────| connections, │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ 注：模型中的每一个方块代表事件循环的一个阶段。 （这块引用 Node 官网上的一篇文章 https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/，有兴趣的朋友可以看看原文） 事件循环各阶段详解从上面这个模型中，我们大致可以分析出 Node.js 中事件循环的顺序： 外部输入数据 –&gt; 轮询阶段(poll) –&gt; 检查阶段(check) –&gt; 关闭事件回调阶段(close callback) –&gt; 定时器检测阶段(timers) –&gt; I/O 事件回调阶段(I/O callback) –&gt; 闲置阶段(idle, prepare) –&gt; 轮询阶段… 各阶段的功能大致如下： timers 阶段：这个阶段执行 setTimeout() 和 setInterval() 的回调； I/O callbacks 阶段：这个阶段执行除了close 事件、定时器和 setImmediate() 的回调之外的其它回调； idle，prepare 阶段：仅 Node 内部使用，可以不用理会； poll 阶段：获取新的 I/O 事件，在一些特殊情况下 Node 会阻塞在这里； check 阶段：执行 setImmediate() 的回调； close callbacks 阶段：比如 socket.on(‘close’, callback) 的回调会在这个阶段执行。 每个阶段都有一个装有 callbacks 的 queue(队列)，当 event loop 执行到一个指定阶段时，Node 将按先进先出的顺序执行该阶段的队列，当队列的 callback 执行完或者执行 callbacks 数量超过该阶段的上限时，event loop 会进入下一个阶段。 下面我们来详细说说各个阶段： poll 阶段poll 阶段是衔接整个 event loop 各个阶段比较重要的阶段。在 Node.js 里，任何异步方法（除 timer， close， setImmediate 之外）完成时，都会将 callback 加到 poll queue 里，并立即执行。 当 V8 引擎将 JS 代码解析并传入 libuv 引擎后，循环首先进入 poll 阶段。poll 阶段的执行逻辑如下： 先查看 poll queue 中是否有事件，如果有，就按顺序依次执行 callbacks。 当 poll queue 为空时， 会检查是否有 setImmediate() 的 callback，如果有就进入 check 阶段执行这些 callback。 同时也会检查是否有到期的 timer，如果有，就把这些到期的 timer 的 callback 按照调用顺序放到 timer queue 中，之后循环会进入 timer 阶段执行 timer queue 中的 callback。这两者的顺序是不固定的，受到代码运行环境的影响。如果两者的 queue 都是空的，那么 event loop 会停留在 poll 阶段，直到有一个 I/O 事件返回，循环会进入 I/O callback 阶段，并立即执行这个事件的 callback。 check 阶段check 阶段专门用来执行 setImmediate() 方法的 callback，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有 callback 时，事件循环进入这个阶段。 close 阶段当一个 socket 连接或者一个 handle 被突然关闭时（例如，调用了 socket.destroy() 方法），close 事件会被发送到这个阶段执行回调；否则事件会用 process.nextTick() 方法发送出去。 timers 阶段这个阶段执行所有到期的 timer 加入到 timer queue 中 callback。timer callback 指通过 setTimeout() 或 setInterval() 设定的 callback。 I/O callback 阶段这个阶段主要执行大部分 I/O 事件的 callback，包括一些为操作系统执行的 callback，例如：一个 TCP 连接发生错误时，系统需要执行 callback 来获得这个错误的报告。 process.nextTick() 与 setImmediate()Node.js 中有三个常用的用来推迟任务执行的方法，分别是：process.nextTick()，setTimeout()（setInterval() 与之相同）和 setImmediate()。 process.nextTick()process.nextTick() 不在 event loop 的任何阶段内执行，而是在各个阶段切换的中间执行，即一个阶段执行完毕准备进入到下一个阶段前执行。 下面我们来看一段代码： const fs = require(&#39;fs); fs.readFile(__filename, () =&gt; { setTimeout(() =&gt; { console.log(&#39;setTimeout); }, 0); setImmediate(() =&gt; { console.log(&#39;setImmediate&#39;); process.nextTick(() =&gt; { console.log(&#39;nextTick3&#39;); }); }); process.nextTick(() =&gt; { console.log(&#39;nextTick1&#39;); }); process.nextTick(() =&gt; { console.log(&#39;nextTick2&#39;); }); }); 结果为： nextTick1 nextTick2 setImmediate nextTick3 setTimeout 从 poll –&gt; check 阶段，先执行process.nextTick，输出 nextTick1，nextTick2；然后进入 check 阶段，执行setImmediate，输出 setImmediate；执行完 setImmediate 后，出 check，进入 close callback 前，输出 nextTick3；最后进入 timer 阶段，执行 setTimeout，输出 setTimeout。 setImmediate()在三个方法中，setImmediate() 和 setTimeout() 这两个方法很容易被弄混，然而实际上这两个方法的意义确大为不同。 setTimeout()是定义一个回调，并且希望这个回调在指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准地执行。 setImmediate() 从意义上是立即执行的意思，但实际上是在一个固定的阶段（poll 阶段之后）才会执行回调。这个名字的意义和上面提到的 process.nextTick() 才是最匹配的。 setImmediate() 和 setTimeout(fn, 0) 表现上非常相似。猜猜下面这段代码的结果是什么？ setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;); }, 0); setImmediate(() =&gt; { console.log(&#39;setImmediate&#39;); }); 答案是不确定。这取决于这段代码的运行环境，运行环境中各种复杂情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个 I/O 事件的回调中。下面这段代码的顺序永远是固定的： const fs = require(&#39;fs&#39;); fs.readFile(__filename, () =&gt; { setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;); }, 0); setImmediate(() =&gt; { console.log(&#39;setImmediate&#39;); }); }); 答案永远是： setImmediate setTimeout 在 I/O 事件的回调中，setImmediate() 方法的回调永远在 setTimeout() 的回调前执行。 从上面 process.nextTick() 的示例代码我们可以看出：多个 process.nextTick() 总是在一次 event loop 执行完；多个 setImmediate() 可能需要多次 event loop 才能执行完。这正是 Node.js 10.0 版添加 setImmediate() 方法的原因，否则像下面这样递归调用 process.nextTick() 时，将会导致 Node 进入死循环，主线程根本不会去读取事件队列。 process.nextTick(function foo() { process.nextTick(foo); }); 小结JavaScript 的事件循环是这门语言中非常重要且基础的概念，清楚的了解事件循环的执行顺序和各阶段的特点，可以使我们对一段异步代码的执行顺序有一个清晰的认知，从而减少代码执行的不确定性。 参考资料 这一次，彻底弄懂 JavaScript 执行机制 从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 JavaScript 运行机制详解：再谈 Event Loop 详解 JavaScript 中的 Event Loop（事件循环）机制 The Node.js Event Loop, Timers, and process.nextTick()","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"从进程和线程了解浏览器的工作原理","date":"2018-06-14T16:00:00.000Z","path":"2018/06/15/how-does-browser-work/","text":"进程和线程进程（process）和线程（thread）是操作系统的基本概念。 现代操作系统都是可以同时运行多个任务的，比如：用浏览器上网的同时还可以听音乐。对于操作系统来说，一个任务就是一个进程，比如打开一个浏览器就是启动了一个浏览器进程，打开一个 Word 就启动了一个 Word 进程。 有些进程同时不止做一件事，比如 Word，它同时可以进行打字、拼写检查、打印等事情。在一个进程内部，要同时做多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程。 由于每个进程至少要做一件事，所以一个进程至少有一个线程。 系统会给每个进程分配独立的内存，因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段，数据集，堆等）。 如果电脑是 windows 系统，打开任务管理器，可以看到有一个后台进程列表，在这里我们可以看到每个进程的内存资源信息以及 CPU 占有率。 我们再用官方的术语描述一下： 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。 浏览器是多进程的理解了进程和线程之后，接下来我们对浏览器进行一定程度上的认识。 浏览器是多进程的，每打开一个 tab 页，就相当于创建了一个独立的浏览器进程。 图中打开了 Chrome 浏览器的多个 tab 页，在 Chrome 任务管理器中可以看到有多个进程，每一个 tab 页有一个独立的进程。 注意：浏览器应该也有自己的优化机制，有时候打开多个 tab 页，在 Chrome 任务管理器中会看到有些进程被合并了，所以每个 tab 页对应一个进程并不一定是绝对的。 浏览器包含哪些进程？为了简化理解，这里仅列举主要进程。 Browser 进程：浏览器的主进程，只有一个。 负责浏览器界面的显示与交互； 各个页面的管理，创建和销毁其他进程； 网络的资源管理、下载等。 Renderer 进程：也称为浏览器渲染进程或浏览器内核，内部是多线程的。主要负责页面渲染，脚本执行，事件处理等。 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。 GPU 进程：最多一个，用于 3D 绘制等。 浏览器多进程的优势 由于默认 新开 一个 tab 页面 新建 一个进程，所以单个 tab 页面崩溃不会影响到整个浏览器； 同样，第三方插件崩溃也不会影响到整个浏览器； 多进程可以充分利用现代 CPU 多核的优势； 方便使用沙盒模型隔离插件等进程，提高浏览器的稳定性。 系统为浏览器新开的进程分配内存、CPU 等资源，所以内存和 CPU 的资源消耗也会更大。 浏览器内核（渲染进程）前面说了这么多的进程，对普通前端操作来说，最重要的还是渲染进程。 浏览器的渲染进程是多线程的，页面的渲染，JS的执行，事件的循环等，都在这个进程内执行。 渲染进程通常由以下常驻线程组成： 1. GUI 渲染线程负责渲染浏览器界面，解析 HTML、CSS，构建 DOM tree和 render tree，布局和绘制等。当界面需要重绘（repaint）或由于某种操作引发回流（reflow）时，该线程就会执行。 2. JS 引擎线程也称为 JS 内核，负责解析 JavaScript 脚本，运行代码。 JavaScript 是单线程的。 JavaScript 为什么是单线程的？这与它的用途有关。JavaScript 作为浏览器脚本语言，主要用途是与用户互动以及操作 DOM。这也决定了它只能是单线程的，否则会带来很复杂的同步问题。想想一下，如果 JavaScript 同时有连个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个 DOM 节点，这时浏览器应该以哪个线程为准呢？所以，为了避免复杂性，JavaScript 从一开始就是单线程。 GUI 渲染线程 与 JS 引擎线程是互斥的。 由于 JavaScript 可以操作 DOM，如果在修改元素属性的同时渲染界面（即 JavaScript 引擎线程和 GUI 渲染线程同时运行），那么渲染线程前后获得的元素数据就可能会不一致。因此，为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系。当 JS 引擎执行时，GUI 线程被挂起，GUI 更新被保存在一个队列中，等到 JS 引擎线程空闲时立即被执行。 JS 阻塞页面加载。 由于 GUI 渲染线程与 JS 引擎线程是互斥的，当浏览器在执行 JavaScript 的时候，GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成，才会接着执行。因此如果 JS 执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 3. 事件触发线程当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎处理。这些事件可以是当前执行的代码块，如定时任务；也可以是来自浏览器内核的其他线程，如：鼠标点击、Ajax异步请求等。但由于 JS 是单线程的，这些事件都需要排队等待 JS 引擎处理。 4. 定时触发器线程setTimeout 和 setInterval 所在的线程。浏览器定时计数器并不是由 JS 引擎计数的，因为 JS 是单线程的，如果处于阻塞线程状态就会影响计时的准确，所以通过单独的线程来计时并触发定时更为合理。 5. 异步 http 请求线程XMLHttpRequest 在建立连接后，通过浏览器新开一个线程请求，一旦检测到状态变更并且设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，等待 JS 引擎空闲时处理。 Browser 进程和 Renderer 进程的通信过程打开浏览器的一个 tab 页时，我们看下其中的大致过程： Browser 进程收到用户请求，通过网络下载获取页面内容，然后将该任务通过RendererHost接口传递给 Renderer 进程； Renderer 进程的 Renderer 接口收到消息，简单解释后，交给 GUI 渲染线程开始渲染； GUI 渲染线程接收请求，加载网页并渲染网页，这个过程中可能需要 Browser 进程获取资源和 GPU 进程来帮助渲染，也可能会有 JS 引擎线程操作 DOM（可能造成回流并重绘）； 最后 Renderer 进程将结果传递给 Browser 进程； Browser 进程接收到结果，并将结果绘制出来。 到这里应该对浏览器的运作有一定理解了，我们再来看下浏览器是怎么渲染页面的。 浏览器的渲染流程浏览器内核拿到页面内容后，渲染过程大概分为以下几个部分： 解析 HTML 文件，生成 DOM tree；同时解析 CSS 文件以及样式元素中的样式数据，生成 CSS Rules。 构建 render tree：根据 DOM tree 和 CSS Rules 来构建 render tree，它可以让浏览器按照正确的顺序绘制内容。 布局（layout / reflow）：计算各元素尺寸、位置。 绘制（paint）：绘制页面像素信息。 浏览器将各层信息发送给 GPU，GPU 将各层信息合成（composite），显示在屏幕上。 补充： Webkit 将 render tree 中的元素称为 render object （或 renderer），每一个 render object 都代表一个的矩形区域，通常对应于相关节点的 CSS 框，这些矩形的排列顺序就是它们在屏幕上显示的顺序。 Render object 和 DOM 节点是相对应的，但并非一一对应。非可视化的 DOM 元素不会插入 render tree 中，例如“head”元素 和 一些 display: none 的节点就没必要放在 render tree 中了。 这里只是大致的过程，详细步骤可以看参考文章中的第一篇。 渲染完成后，接下来就是 JavaScript 逻辑处理了。 参考资料 浏览器的工作原理：新式网络浏览器幕后揭秘 从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"JavaScript：事件对象","date":"2017-03-30T16:00:00.000Z","path":"2017/03/31/JavaScript：事件对象/","text":"&emsp;&emsp;在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。 &emsp;&emsp;所有浏览器都支持 event 对象，但支持方式不同。 DOM中的事件对象&emsp;&emsp;兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级），都会传入 event 对象。 var btn = document.getElementById(&#39;myBtn&#39;); btn.onclick = function(event) { alert(event.type); // click }; btn.addEventListener(&#39;click&#39;, function(event) { alert(event.type); // click }, false); &emsp;&emsp;在通过 HTML 特性指定事件处理程序时，变量 event 中保存着 event 对象。 &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;/&gt; &emsp;&emsp;event 对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都会有下表列出的成员。 属性/方法 类 型 读/写 说明 bubbles Boolean 只读 表明事件是否冒泡 cancelable Boolean 只读 表明是否可以取消事件的默认行为 currentTarget Element 只读 其事件处理程序当前正在处理事件的那个元素 defaultPrevented Boolean 只读 为 true表示已经调用了preventDefault()（DOM3级事件中新增） detail Integer 只读 与事件相关的细节信息 eventPhase Integer 只读 调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段 preventDefault() Function 只读 取消事件的默认行为。如果 cancelable 是 true，则可以使用这个方法 stopImmediatePropagation() Function 只读 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3 级事件中新增） stopPropagation() Function 只读 取消事件的进一步捕获或冒泡。如果 bubbles 为 true，则可以使用这个方法 target Element 只读 事件的目标 trusted Boolean 只读 为true表示事件是浏览器生成的。为 false 表示事件是由开发人员通过JavaScript创建的（DOM3级事件中新增） type String 只读 被触发的事件的类型 view AbstractView 只读 与事件关联的抽象视图。等同于发生事件的 window 对象 在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 this，currentTarget 和 target 包含相同的值。 var btn = document.getElementById(&#39;myBtn&#39;); btn.onclick = function(event) { alert(event.currentTarget === this); // true alert(event.target === this); // true }; 如果事件处理程序存在于按钮的父节点中（例如 document.body），那么这些值是不相同的。 document.body.onclick = function(event) { alert(event.currentTarget === document.body); // true alert(this === document.body); // true alert(event.target === document.getElementById(&#39;myBtn&#39;)); // 点击&#39;myBtn&#39;，结果为true；点击body,结果为false }; 注：只有在事件处理程序执行期间， event 对象才会存在；一旦事件处理程序执行完成， event 对象就会被销毁。 IE中的事件对象&emsp;&emsp;与访问 DOM 中的 event 对象不同，要访问 IE 中的 event 对象有几种不同的方式，取决于指定事件处理程序的方法。 在使用 DOM0 级方法添加事件处理程序时， event 对象作为 window 对象的一个属性存在。var btn = document.getElementById(&#39;myBtn&#39;); btn.onclick = function() { var event = window.event; alert(event.type); // click }; 在使用 DOM2级方法 添加事件处理程序时， event 对象作为参数被传入事件处理程序函数中。var btn = document.getElementById(&#39;myBtn&#39;); btn.attachEvent(&#39;onclick&#39;, function(event) { alert(event.type); // click }); 在 HTML特性 指定的事件处理程序中，通过 event 变量来访问 event对象（与 DOM中的事件模型相同）。&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; &emsp;&emsp;IE 的 event 对象同样也包含与创建它的事件相关的属性和方法。其中很多属性和方法都有对应的或者相关的 DOM属性和方法。所有事件对象都会包含下表所列的属性和方法： 属性/方法 类 型 读/写 说明 cancelBubble Boolean 读/写 默认值为 false，但将其设置为 true，就可以取消事件冒泡（与DOM中的 stopPropagation() 方法的作用相同） returnValue Boolean 读/写 默认值为 true，但将其设置为 false，就可以取消事件的默认行为（与DOM中的 preventDefault() 方法的作用相同），但没有办法确定事件是否能被取消 srcElement Element 只读 事件的目标（与DOM中的 target 属性相同） type String 只读 被触发的事件的类型 跨浏览器的事件对象var EventUtil = { getEvent: function(event) { return event ? event : window.event; }, getTarget: function(event) { return event.target || event.srcElement; }, preventDefault: function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, stopPropagation: function(event) { if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } }, addHandler: function(element, type, handler) { if (element.addEventListener) { element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(&#39;on&#39; + type, handler); } else { element[&#39;on&#39; + type] = handler; } }, removeHandler: function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(&#39;on&#39; + type, handler); } else { element[&#39;on&#39; + type] = null; } } };","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"JavaScript：事件流 & 事件处理程序","date":"2017-03-29T16:00:00.000Z","path":"2017/03/30/JavaScript：事件流&事件处理程序/","text":"定义：事件：用户或浏览器自身执行的某种动作。事件流：描述的是从页面中接收事件的顺序，也可理解为事件在页面中传播的顺序。事件处理程序：响应某个事件的函数就叫做事件处理程序（或事件侦听器）。 事件流（1）事件冒泡 IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。如下图所示： IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 window 对象。 （2）事件捕获 事件捕获的思想与事件冒泡的思想几乎完全相反，是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。如下图所示： （3）DOM事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段 和 事件冒泡阶段。 首先发生的是事件捕获，为截获事件提供了机会。 然后是实际的目标接收到事件。 最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。 在 DOM 事件流中，实际的目标（ 元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从 document 到 再到 后就停止了。下一个阶段是“处于目标”阶段，于是事件在 上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 IE9,Opera,Firefox,Chrome 和 Safari 都支持 DOM 事件流；IE8 及更早版本不支持 DOM 事件流。 事件处理程序 响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以 “on” 开头，因此click 事件的事件处理程序就是 onclick，load 事件的事件处理程序就是 onload 。为事件指定处理程序的方式有以下几种： （1）HTML事件处理程序&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&#39;Clicked&#39;)&quot; /&gt; 缺点： 存在时差问题：因为用户可能会在HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件，就会引发错误。 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。 HTML 与 JavaScript 代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码。 （2）DOM0级事件处理程序 即将一个函数赋值给一个事件处理程序属性。 var btn = document.getElementById(&#39;myBtn&#39;); btn.onclick = function() { alert(&#39;Clicked&#39;); }; btn.onclick = null; // 删除事件处理程序 优点： 简单 可跨浏览器 （3）DOM2级事件处理程序addEventListener(事件名称, 事件函数, 是否捕获); // 添加事件处理程序 removeEventListener(事件名称, 事件函数, 是否捕获); // 移除事件处理程序 所有 DOM 节点中都包含这两个方法。 优点：可以添加多个事件处理程序。 通过 addEventListener() 添加的事件处理程序只能使用 removeEventListener() 来移除。所以通过 addEventListener() 添加的匿名函数将无法移除。 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。 （4）IE事件处理程序attachEvent(事件名称, 事件函数); // 添加事件处理程序 detachEvent(事件名称, 事件函数); // 移除事件处理程序 由于 IE8 及更早版本只支持事件冒泡，所以通过 attachEvent() 添加的事件处理程序都会被添加到冒泡阶段。 注：例如 添加点击事件，attachEvent() 的第一个参数是 “onclick”，而非 DOM 的 addEventListener() 方法中的 “click” 。 在 IE 中使用 attachEvent() 与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用 attachEvent() 方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window 。 attachEvent() 也可以用来为一个元素添加多个事件处理程序。不过，与 DOM 方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。例如：下面的例子，点击按钮，首先看到的是 “Hello world!”，然后是 “Clicked”。 var btn = document.getElementById(&#39;myBtn&#39;); btn.attachEvent(&#39;onclick&#39;, function() { alert(&#39;Clicked&#39;); }); btn.attachEvent(&#39;onclick&#39;, function() { alert(&#39;Hello world!&#39;); }); （5）跨浏览器的事件处理程序 首先要创建的方法是 addHandler() ，它的职责是视情况分别使用 DOM0 级方法、DOM2 级方法或 IE 方法来添加事件。这个方法属于一个名叫 EventUtil 的对象。 addHandler() 方法接受 3 个参数：要操作的元素、事件名称和事件函数。 var EventUtil = { addHandler: function(element, type, handler) { // 添加事件 if (element.addEventListener) { element.addEventListener(type,handler,false); // 使用DOM2级方法添加事件 } else if (element.attachEvent) { // 使用IE方法添加事件 element.attachEvent(&quot;on&quot;+type,handler); } else { element[&quot;on&quot;+type]=handler; // 使用DOM0级方法添加事件 } }, removeHandler: function(element, type, handler) { // 取消事件 if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(&quot;on&quot;+type,handler); } else { element[&quot;on&quot;+type]=null; } } } 使用 EventUtil 对象 var btn = document.getElementById(&#39;myBtn&#39;); var handler = function() { alert(&#39;Clicked&#39;); }; EventUtil.addHandler(btn, &#39;click&#39;, handler); EventUtil.removeHandler(btn, &#39;click&#39;, handler);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"AJAX的工作原理","date":"2017-02-11T16:00:00.000Z","path":"2017/02/12/how-ajax-works/","text":"什么是 AJAX ？ AJAX = 异步 JavaScript 和 XML &emsp;&emsp;AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用AJAX）如果需要更新内容，必需重载整个网页面。 创建AJAX的过程&emsp;&emsp;XMLHttpRequest 是 AJAX 的基础，用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 (1) 创建 XMLHttpRequest 对象var xmlHttp = new XMLHttpRequest(); // IE7及以上 var xmlHttp = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); // IE5 和 IE6 (2) 打开连接xmlHttp.open(method, url, async); method：请求的类型，GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） 同步：指发出数据后，等接收到响应以后再发送下一个数据包的通讯方式。异步：指发出数据后，不用等待接收到响应，接着发送下一个数据包的通讯方式。 (3) 向服务器发送请求xmlHttp.send(string); GET 请求: xmlHttp.send(); POST 请求: xmlHttp.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;); // 向请求添加HTTP头 xmlHttp.send(&#39;fname=Bill&amp;lname=Gates&#39;); GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： a. 无法使用缓存文件（更新服务器上的文件或数据库）； b. 向服务器发送大量数据（POST 没有数据量限制）； c. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠。 (4) 接收服务器响应当请求被发送到服务器时，我们需要执行一些基于响应的任务。 XMLHttpRequest 对象有三个重要的属性： Onreadystatechange 存储函数（或函数名），每当readyState 属性改变时，就会调用该函数。 readyState 存有XMLHttpRequest 的状态信息，从 0 到 4 发生变化。&emsp;&emsp; 0: 请求未初始化&emsp;&emsp; 1: 服务器连接已建立&emsp;&emsp; 2: 请求已接收&emsp;&emsp; 3: 请求处理中&emsp;&emsp; 4: 请求已完成，且响应已就绪 Status（HTTP状态码）&emsp;&emsp; 1字头：消息。这一类型的状态码，代表请求已被接受，需要继续处理。&emsp;&emsp; 2字头：成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。( 200:’OK’ )&emsp;&emsp; 3字头：重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。( 304:’Not Modified’ )&emsp;&emsp; 4字头：请求错误。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。&emsp;&emsp; 5、6字头：服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生。 每当 readyState 改变时，就会触发 onreadystatechange 事件。在onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当readyState 等于 4 且 status 为 2字头或 304 时，表示响应已就绪： xmlHttp.onreadystatechange = function() { if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status &gt;= 200 &amp;&amp; xmlHttp.status &lt; 300 || xmlhttp.status == 304) { document.getElementById(&quot;myDiv&quot;).innerHTML = xmlHttp.responseText; // responseText 获得字符串形式的响应数据 } } 下面是封装的ajax函数： GET 方式： function ajax(url, success, error) { if (window.XMLHttpRequest) { var oAjax = new XMLHttpRequest(); } else { var oAjax = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); } oAjax.open(&#39;GET&#39;, url, true); oAjax.send(); oAjax.onreadystatechange = function() { if (oAjax.readyState == 4) { if (oAjax.status &gt;= 200 &amp;&amp; oAjax.status &lt; 300 || oAjax.status == 304) { success &amp;&amp; success(oAjax.responseText); // 成功的回调函数 } else { error &amp;&amp; error(oAjax.status); // 失败的回调函 } } }; } POST 方式： function ajax(url, success, error) { if (window.XMLHttpRequest) { var oAjax = new XMLHttpRequest(); }else{ var oAjax = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); } oAjax.open(&#39;POST&#39;, url, true); oAjax.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); oAjax.send(&#39;fname=Bill&amp;lname=Gates&#39;); oAjax.onreadystatechange = function() { if (oAjax.readyState == 4) { if (oAjax.status &gt;=200 &amp;&amp; oAjax.status &lt; 300 || oAjax.status == 304) { success&amp;&amp;success(oAjax.responseText); // 成功的回调函数 } else { error&amp;&amp;error(oAjax.status); // 失败的回调函 } } }; }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"CSS清除浮动的方法","date":"2017-02-06T16:00:00.000Z","path":"2017/02/07/CSS清除浮动的方法/","text":"前言摘要： 浮动的元素可以向左或向右移动，直到它的外边缘碰到父容器或另一个浮动元素为止。由于浮动元素不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动元素不存在一样。由于浮动的这种特性，当本属于普通流中的元素浮动之后，父容器内部由于不存在其他普通流元素了，所以表现出高度为0（“高度塌陷”）。但在实际布局中，这并不是我们所希望的，所以需要清除浮动，使父容器表现出正常的高度。 正文引用W3C的例子，news容器没有包围浮动的元素。 .news { background-color: gray; border: 1px solid black; } .news img { float: left; } .news p { float: right; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 清除浮动的方法方法一：设置高度 给浮动元素的父元素设置height值，如 .news { height: **px; } 问题：扩展性不好，只适合固定高度的布局，不推荐使用。 方法二：给浮动元素的父元素添加浮动 给浮动元素的父元素也添加浮动属性可以清除内部浮动，但是这样会使页面中所有元素都加浮动，margin左右auto失效，影响布局，不推荐使用。 方法三：inline-block 清除浮动方法 给浮动元素的父元素设置 display 属性为 inline-block问题：margin 左右 auto 失效 方法四：空标签清除浮动 在浮动元素的末尾添加一个空元素，如 &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 并在 CSS 中添加 .clear { clear: both; } 即可清除浮动。 .news { background-color: gray; border: 1px solid black; } .news img { float: left; } .news p { float: right; } .clear { clear: both; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; 优点：简单，浏览器兼容性好。缺点：需要添加大量无意义的空元素，有违结构与表现的分离，后期不容易维护。 方法五：使用相邻元素 给浮动元素后面的元素添加clear属性，如 .news { background-color: gray; border: 1px solid black; } .news img { float: left; } .news p { float: right; } .clear { clear: both; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;div class=&quot;clear&quot;&gt;xxxxxx(内容)&lt;/div&gt; &lt;/div&gt; 方法六：使用overflow属性 给浮动元素的父元素添加 overflow: hidden; // 或 overflow: auto; 在IE6中还需触发 hasLayout，例如 zoom:1。 .news { background-color: gray; border: 1px solid black; overflow: hidden; zoom: 1; } .news img { float: left; } .news p { float: right; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 优点：简单，代码少，不存在结构和语义化问题。缺点：无法显示需要溢出的内容。 方法七：使用 :after 伪元素 需要注意的是 :after 是伪元素（代表一个元素之后最近的元素），不是伪类。给浮动元素的父元素添加一个 class，然后给这个 class 添加一个 :after 伪元素实现元素末尾添加一个看不见的块元素来清除浮动。由于 IE6-7 不支持 :after，需要使用 zoom:1 触发 hasLayout。 .news { background-color: gray; border: 1px solid black; } .news img { float: left; } .news p { float: right; } .clearfix:after { content: &quot;.&quot;; //生成内容作为最后一个元素，点可以换为其他（如:一个看不见的空格&quot;020&quot;） display: block; //使生成的元素以块级元素显示,占满剩余空间; height: 0; //避免生成内容破坏原有布局的高度 visibility: hidden; //使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互 clear: both; } .clearfix { zoom: 1; //触发 hasLayout } &lt;div class=&quot;news clearfix&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 优点：结构和语义化完全正确，代码量适中，可重复利用（建议定义公共类），推荐使用。缺点：复用方式不当会造成代码量增加。 总结通过以上方法，我们不难发现清除浮动的方法可以分为两类： 一是在浮动元素的末尾添加一个空元素，并设置 clear 属性值为 both，其实 :after 伪元素也是在浮动元素的后面添加了内容为一个点的块元素； 二是通过设置父元素 overflow 属性来清除浮动。 在网页主要布局中通常使用 :after 伪元素来清除浮动，在一些小的模块中使用 overflow:hidden 来清除浮动。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://zouyang0921.com/tags/CSS/"}]}]