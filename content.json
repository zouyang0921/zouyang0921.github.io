[{"title":"JavaScript 模块化","date":"2018-08-13T16:00:00.000Z","path":"2018/08/14/javascript-modularity/","text":"随着 JavaScript 日新月异的发展，超过了它产生时候的自我定位，由于没有模块管理的概念，在做大型项目或文件组织的时候，就会异常纠结，而且后续也很难维护，长此以往，模块化是必然趋势~ 模块化的主要特征是: 可复用 封装了变量和函数，和全局的 namaspace 不接触，松耦合 只暴露可用的 public 方法，其它私有方法全部隐藏 目前比较流行的 JS 模块化规范有 CommonJS、AMD、CMD、UMD 以及 ES6 的模块化。 CommonJSNode.js 是 CommonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，通过 module.exports 导出对外的变量或接口，通过 require 导入其它模块的输出到当前的模块的作用域中。 模块定义// 定义模块 math.js var basicNum = 0; function add(a, b) { return a + b; } module.exports = { // 在这里写需要向外暴露的变量或函数 basicNum: basicNum, add: add }; 模块引用// 引入自定义的模块，参数需要包含路径，可省略后缀.js var math = require(&#39;./math); math.add(3, 5); // 引入核心模块，参数直接写模块名，不需要包含路径 var http = require(&#39;http&#39;); http.createServer(...).listen(8080); module.exports v.s. exports很多时候，我们会看到在一个模块中有两种方式来输出变量： 方式一：对 module.exports 赋值 // hello.js function sayHello() { console.log(&#39;Hello&#39;); } function sayGoodbye() { console.log(&#39;Goodbye&#39;); } module.exports = { sayHello: sayHello, sayGoodbye: sayGoodbye }; 方式二：直接使用 exports // hello.js function sayHello() { console.log(&#39;Hello&#39;); } function sayGoodbye() { console.log(&#39;Goodbye&#39;); } exports.sayHello = sayHello; exports.sayGoodbye = sayGoodbye; 但是，不可以直接对 exports 赋值。 // 代码可以执行，但是并没有输出任何变量 exports = { sayHello: sayHello, sayGoodbye: sayGoodbye }; 原因是什么呢？我们来分析一下 Node.js 的加载机制。 首先，Node.js 会把待加载的文件 hello.js 放入一个包装函数 load() 中执行。在执行 load() 函数前，Node.js 准备好了 module 变量： var module = { id: &#39;hello&#39;, exports: {} }; load() 函数最终返回 module.exports： var load = function(module) { // hello.js 文件的内容 ... // load 函数返回 return module.exports; }; var exports = load(module); 也就是说，exports 实际上是 module.exports 的引用，或者理解为 exports 是一个指针，指向 module.exports ，所以在使用 exports 的时候，只能是 exports.sayHello = function() {...} 这样的方式，而不能使用 exports = { sayHello: function() {}} 这种方式相当于重新定义了 exports，module.exports 仍然是空对象 {}，所以给 exports 赋值是无效的。 优点：解决了依赖、全局变量污染的问题。 缺点：CommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 AMDAMD( Asynchronous Module Definition ) 是 Require.js 在推广过程中对模块定义的规范化产出。 AMD 规范采用异步方式加载模块，所有依赖这个模块的语句都定义在一个回调函数中，等到加载完成后，这个回调函数才会执行。 实现 AMD 规范的模块化通过 define() 方法将代码定义为模块，通过 require() 方法实现模块的加载。 这里以 require.js 为例，首先将 require.js 引入到页面中： &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; 定义模块（1）独立模块 即 不需要依赖任何其他模块 // math.js define(function() { var basicNum = 0; var add = function(a, b) { return a + b; }; return { basicNum: basicNum, add: add }; }); （2）非独立模块 即 需要依赖其他模块 define([&#39;underscore&#39;], function(_) { var classify = function(list) { _.countBy(list, function(num) { return num &gt; 30 ? &#39;old&#39; : &#39;young&#39;; }); }; return { classify: classify }; }); 引用模块require([&#39;jquery&#39;, &#39;math&#39;], function($, math) { var sum = math.add(3, 5); $(&#39;#sum&#39;).html(sum); }); require.js 还提供了一个 API： require.config() ，可以用来配置项目中用到的基础模块。 // 通过 config() 指定各模块路径和引用名 require.config({ baseUrl: &#39;js/lib&#39;, paths: { &#39;jquery&#39;: &#39;jquery.min&#39;, // 实际路径为 js/lib/jquery.min.js &#39;underscore&#39;: &#39;underscore.min&#39; } }); // 引入模块 require([&#39;jquery&#39;, &#39;underscore&#39;]， function($, _) { ... }); 优点：适合在浏览器环境中异步加载模块，可以并行加载多个模块。 缺点：不能按需加载，开发成本大。 CMDCMD( Common Module Definition ) 是 Sea.js 在推广过程中对模块定义的规范化产出。 AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。 // AMD 写法 define([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], function(a, b, c, d, e) { // 等于在最前面声明并初始化了所有依赖的模块 a.doSomething(); if (false) { // 即使没有用到某个模块 b，但 b 还是提前执行了 b.doSomething(); } }); // CMD 写法 define(function(require, exports, module) { var a = require(&#39;./a); // 在需要时声明 a.doSomething(); if (false) { var b = require(&#39;./b); b.doSomething(); } }); UMDUMD ( Universal Module Definition )，希望提供一个前后端跨平台的解决方案(支持 AMD 与 CommonJS 模块方式)。 UMD 的实现原理： 先判断是否支持 Node.js 模块格式( exports 是否存在 )，存在则使用 Node.js 模块格式。 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。 前两个都不存在，则将模块公开到全局( window 或 global )。 下面是一个示例： eventUtil.js (function(root, factory) { if (typef exports === &#39;object&#39;) { module.exports = factory(); } else if (typeof define === &#39;function&#39; &amp;&amp; define.amd) { define(factory); } else { root.eventUtil = factory(); } })(this, function() { // module return { addEvent: function(el, type, handle) { // ... }, removeEvent: function(el, type, handle) { // ... } }; }); ES6 Module在 ES6 中， 我们可以通过 import 引入模块，通过 export 导出模块，功能比前几个方案更强大，也是我们推荐使用的，但是由于浏览器对 ES6 的支持程度不同，目前都是使用 babel 或 traceur 把 ES6 代码转化为 ES5 代码，然后再在浏览器环境中执行。 // 定义模块 math.js var basicNum = 0; var add = function(a, b) { return a + b; }; export { basicNum, add }; // 引用模块 import { basicNum, add } from &#39;./math&#39;; function test(element) { element.textContent = add(basicNum, 99); } test(); 导出模块时还可以用 export default ，为模块指定默认输出，对应的 import 语句不需要使用大括号。 // 输出模块 export default { basicNum, add } // 引入模块 import math from &#39;./math&#39;; 注：一个模块只能有一个 export default。 CommonJS 与 ES6 模块化的差异1. CommonJS 支持动态导入，也就是 require(${path}/xx.js) ，ES6 目前还不支持，但是已有提案。 2. CommonJS 是同步导入，ES6是异步导入。 CommonJS 因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。 ES6 因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响。 3. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值；另一方面，如果导出的值变了，导入的值也不会变，所以如果想更新值，必须重新导入一次。 ES6 采用实时绑定的方式，导入和导出的值都指向同一个内存地址，所以导入的值会跟随导出的值变化。 4. CommonJS 模块是运行时加载，ES6 模块是编译时加载。 CommonJS 模块就是一个对象，在导入时先加载整个模块，生成一个对象( 这个对象只有在脚本运行完才会生成 )，然后再从这个对象上读取方法，这种加载称为“运行时加载”。 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码运行之前( 即编译时 )的静态解析阶段就完成了模块加载，比 CommonJS 模块的加载方式更高效。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"从 Event Loop 谈 JavaScript 的执行机制","date":"2018-07-21T16:00:00.000Z","path":"2018/07/22/javascript-execution-mechanism/","text":"在上一篇文章 从进程和线程了解浏览器的工作原理 中，我们已经了解了浏览器的渲染流程，浏览器初次渲染完成后，接下来就是 JS 逻辑处理了。这篇文章我们结合 event loop 来了解一下 JavaScript 代码是如何执行的。 浏览器环境下 JS 引擎的事件循环机制在 上一篇文章 中我们已经知道了 JavaScript 是单线程的，这意味着 JavaScript 只有一个主线程来处理所有的任务。所以，所有任务都需要排队执行，上一个任务结束，才会执行下一个。如果上一个任务耗时很长，那么下一个任务也要一直等着。 排队通常由两种原因造成： 任务计算量过大，CPU 处理不过来； 执行任务需要的东西没有准备好（如 Ajax 获取到数据才能往下执行），所以无法继续执行，只好等待 IO 设备（输入输出设备），而 CPU 却是闲着的。 JavaScript 的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务，等到 IO 设备返回了结果，再把挂起的任务继续执行下去。 于是，任务可以分为两种： 同步任务：在主线程上排队执行的任务。只有上一个任务执行完，才能执行下一个任务； 异步任务：不进入主线程、而进入任务队列（task queue）的任务。只有任务队列通知主线程某个异步任务可以执行了，该任务才会进入主线程执行。 JavaScript 执行的过程如下： 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外还存在一个任务队列。当遇到一个异步任务时，并不会一直等待其返回结果，而是会将这个异步任务挂起，继续执行执行栈中的其他任务。当一个异步任务返回结果后，就会在任务队列中放置一个事件。 被放入任务队列的事件不会立刻执行其回调，而是等待执行栈中的所有同步任务都执行完毕，主线程处于闲置状态时，主线程就会读取任务队列，看里面是否有事件。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，开始执行。 只要执行栈空了，就会去读取任务队列，主线程从任务队列中读取事件的过程是循环不断的，这种执行机制称为事件循环（event loop）。 这里引用 Philip Roberts的演讲《Help, I’m stuck in an event-loop》中的一张图来协助理解： 图中的 stack 表示我们所说的执行栈，WebAPIs代表一些异步任务，callback queue 则是任务队列。 定时器任务队列除了放置异步任务的事件，还可以放置定时事件，即指定某些代码在多长时间后执行。 定时器功能主要有 setTimeout() 和 setInterval() 这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码只执行一次，后者为反复执行。这里我们主要讨论 setTimeout() 。 setTimeout(function() { console.log(&#39;hello&#39;); }, 3000) 上面这段代码，3000 毫秒后会将该定时事件放入任务队列中，等待主线程执行。 如果将延迟时间设为 0，就表示当前代码执行完（执行栈清空）以后，立刻执行指定的回调函数。 setTimeout(function() { console.log(1); }, 0); console.log(2); 上面代码的执行结果总是： 2 1 因为只有在执行完第二个console.log以后，才会去执行任务队列中的回调函数。 注意： setTimeout(fn, 0)的含义是：指定某个任务在主线程最早可得的空闲时间执行。 虽然代码的本意是 0 毫秒后就将事件放入任务队列，但是 W3C 在 HTML 标准中规定，setTimeout() 的延迟时间不能低于 4 毫秒。 setTimeout() 只是将事件插入了任务队列，必须要等到执行栈执行完毕，主线程才会去执行它指定的回调函数。如果当前代码耗时很长，那这个事件就得一直等待，所以并没有办法保证回调函数一定会在setTimeout() 指定的时间执行。 macro task 与 micro task前面我们已经将 JavaScript 事件循环机制梳理了一遍，在 ES5 中是够用了，但是在 ES6 中仍然会遇到一些问题，比如下面这段代码： setTimeout(function() { console.log(&#39;setTimeout&#39;); }, 0); new Promise(function(resolve) { console.log(&#39;Promise1&#39;); for (var i=0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(&#39;Promise2&#39;); }).then(function() { console.log(&#39;then&#39;); }); console.log(&#39;end&#39;); 它的结果是： Promise1 Promise2 end then setTimeout 为什么呢？这里就需要解释一个新的概念：macro-task 和 micro-task。 除了广义的同步任务和异步任务的划分，对任务还有更精细的定义： macro-task（宏任务）：可以理解为每次执行栈执行的代码就是一个宏任务，包括每次从任务队列中获取一个事件并将其对应的回调放入到执行栈中执行。宏任务需要多次事件循环才能执行完，任务队列中的每一个事件都是一个宏任务。每次事件循环都会调入一个宏任务，浏览器为了能够使 JS 内部宏任务与 DOM 任务有序的执行，会在一个宏任务结束后，下一个宏任务开始前，对页面进行重新渲染。 micro-task（微任务）：可以理解为在当前宏任务执行结束后立即执行的任务。微任务是一次性执行完的，在一个宏任务执行完毕后，就会将它执行期间产生的所有微任务都执行完毕。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务放到队列尾部，之后会依次执行。 形成 macro-task 或 micro-task 的场景： macro-task：script（整体代码），setTimeout，setInterval，setImmediate，I/O，UI 渲染等 micro-task：process.nextTick，Promise（这里指浏览器实现的原生 Promise），Object.observe，MutationObserver 宏任务和微任务执行的顺序如下： 现在我们再来看看上面那段代码是怎么执行的： 整个 script 代码，放在了macro-task 队列中，取出来放入执行栈开始执行； 遇到 setTimeout，加入到 macro-task 队列； 遇到 Promise.then，放入到另一个队列 micro-task 队列； 等执行栈执行完后，下一步该取出 micro-task 队列中的任务了，在这里也就是 Promise.then； 等到 micro-task 队列都执行完后，然后再去取出 macro-task 队列中的setTimeout。 Node.js 中的 Event Loop在 Node.js 中，事件循环表现出的状态与浏览器中大致相同。不同的是Node.js 中有一套自己的模型，它是通过 libuv 引擎来实现事件循环的。 下面我们来看看 Node.js 是如何执行的？ Node.js 是 使用 V8 引擎作为 JS 解释器，V8 引擎将 JS 代码解析后去调用Node API； 这些 API 由 libuv 引擎驱动，执行对应的任务。libuv 引擎将不同的任务分配给不同的线程，形成一个事件循环（event loop），以异步的方式将任务的执行结果返回给 V8 引擎； V8 引擎再将结果返回给用户。 事件循环模型下面是一个 libuv 引擎中的事件循环的模型： ┌───────────────────────┐ ┌─&gt;│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │&lt;─────| connections, │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ 注：模型中的每一个方块代表事件循环的一个阶段。 （这块引用 Node 官网上的一篇文章 https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/，有兴趣的朋友可以看看原文） 事件循环各阶段详解从上面这个模型中，我们大致可以分析出 Node.js 中事件循环的顺序： 外部输入数据 –&gt; 轮询阶段(poll) –&gt; 检查阶段(check) –&gt; 关闭事件回调阶段(close callback) –&gt; 定时器检测阶段(timers) –&gt; I/O 事件回调阶段(I/O callback) –&gt; 闲置阶段(idle, prepare) –&gt; 轮询阶段… 各阶段的功能大致如下： timers 阶段：这个阶段执行 setTimeout() 和 setInterval() 的回调； I/O callbacks 阶段：这个阶段执行除了close 事件、定时器和 setImmediate() 的回调之外的其它回调； idle，prepare 阶段：仅 Node 内部使用，可以不用理会； poll 阶段：获取新的 I/O 事件，在一些特殊情况下 Node 会阻塞在这里； check 阶段：执行 setImmediate() 的回调； close callbacks 阶段：比如 socket.on(‘close’, callback) 的回调会在这个阶段执行。 每个阶段都有一个装有 callbacks 的 queue(队列)，当 event loop 执行到一个指定阶段时，Node 将按先进先出的顺序执行该阶段的队列，当队列的 callback 执行完或者执行 callbacks 数量超过该阶段的上限时，event loop 会进入下一个阶段。 下面我们来详细说说各个阶段： poll 阶段poll 阶段是衔接整个 event loop 各个阶段比较重要的阶段。在 Node.js 里，任何异步方法（除 timer， close， setImmediate 之外）完成时，都会将 callback 加到 poll queue 里，并立即执行。 当 V8 引擎将 JS 代码解析并传入 libuv 引擎后，循环首先进入 poll 阶段。poll 阶段的执行逻辑如下： 先查看 poll queue 中是否有事件，如果有，就按顺序依次执行 callbacks。 当 poll queue 为空时， 会检查是否有 setImmediate() 的 callback，如果有就进入 check 阶段执行这些 callback。 同时也会检查是否有到期的 timer，如果有，就把这些到期的 timer 的 callback 按照调用顺序放到 timer queue 中，之后循环会进入 timer 阶段执行 timer queue 中的 callback。这两者的顺序是不固定的，受到代码运行环境的影响。如果两者的 queue 都是空的，那么 event loop 会停留在 poll 阶段，直到有一个 I/O 事件返回，循环会进入 I/O callback 阶段，并立即执行这个事件的 callback。 check 阶段check 阶段专门用来执行 setImmediate() 方法的 callback，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有 callback 时，事件循环进入这个阶段。 close 阶段当一个 socket 连接或者一个 handle 被突然关闭时（例如，调用了 socket.destroy() 方法），close 事件会被发送到这个阶段执行回调；否则事件会用 process.nextTick() 方法发送出去。 timers 阶段这个阶段执行所有到期的 timer 加入到 timer queue 中 callback。timer callback 指通过 setTimeout() 或 setInterval() 设定的 callback。 I/O callback 阶段这个阶段主要执行大部分 I/O 事件的 callback，包括一些为操作系统执行的 callback，例如：一个 TCP 连接发生错误时，系统需要执行 callback 来获得这个错误的报告。 process.nextTick() 与 setImmediate()Node.js 中有三个常用的用来推迟任务执行的方法，分别是：process.nextTick()，setTimeout()（setInterval() 与之相同）和 setImmediate()。 process.nextTick()process.nextTick() 不在 event loop 的任何阶段内执行，而是在各个阶段切换的中间执行，即一个阶段执行完毕准备进入到下一个阶段前执行。 下面我们来看一段代码： const fs = require(&#39;fs); fs.readFile(__filename, () =&gt; { setTimeout(() =&gt; { console.log(&#39;setTimeout); }, 0); setImmediate(() =&gt; { console.log(&#39;setImmediate&#39;); process.nextTick(() =&gt; { console.log(&#39;nextTick3&#39;); }); }); process.nextTick(() =&gt; { console.log(&#39;nextTick1&#39;); }); process.nextTick(() =&gt; { console.log(&#39;nextTick2&#39;); }); }); 结果为： nextTick1 nextTick2 setImmediate nextTick3 setTimeout 从 poll –&gt; check 阶段，先执行process.nextTick，输出 nextTick1，nextTick2；然后进入 check 阶段，执行setImmediate，输出 setImmediate；执行完 setImmediate 后，出 check，进入 close callback 前，输出 nextTick3；最后进入 timer 阶段，执行 setTimeout，输出 setTimeout。 setImmediate()在三个方法中，setImmediate() 和 setTimeout() 这两个方法很容易被弄混，然而实际上这两个方法的意义确大为不同。 setTimeout()是定义一个回调，并且希望这个回调在指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准地执行。 setImmediate() 从意义上是立即执行的意思，但实际上是在一个固定的阶段（poll 阶段之后）才会执行回调。这个名字的意义和上面提到的 process.nextTick() 才是最匹配的。 setImmediate() 和 setTimeout(fn, 0) 表现上非常相似。猜猜下面这段代码的结果是什么？ setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;); }, 0); setImmediate(() =&gt; { console.log(&#39;setImmediate&#39;); }); 答案是不确定。这取决于这段代码的运行环境，运行环境中各种复杂情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个 I/O 事件的回调中。下面这段代码的顺序永远是固定的： const fs = require(&#39;fs&#39;); fs.readFile(__filename, () =&gt; { setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;); }, 0); setImmediate(() =&gt; { console.log(&#39;setImmediate&#39;); }); }); 答案永远是： setImmediate setTimeout 在 I/O 事件的回调中，setImmediate() 方法的回调永远在 setTimeout() 的回调前执行。 从上面 process.nextTick() 的示例代码我们可以看出：多个 process.nextTick() 总是在一次 event loop 执行完；多个 setImmediate() 可能需要多次 event loop 才能执行完。这正是 Node.js 10.0 版添加 setImmediate() 方法的原因，否则像下面这样递归调用 process.nextTick() 时，将会导致 Node 进入死循环，主线程根本不会去读取事件队列。 process.nextTick(function foo() { process.nextTick(foo); }); 小结JavaScript 的事件循环是这门语言中非常重要且基础的概念，清楚的了解事件循环的执行顺序和各阶段的特点，可以使我们对一段异步代码的执行顺序有一个清晰的认知，从而减少代码执行的不确定性。 参考资料 这一次，彻底弄懂 JavaScript 执行机制 从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 JavaScript 运行机制详解：再谈 Event Loop 详解 JavaScript 中的 Event Loop（事件循环）机制 The Node.js Event Loop, Timers, and process.nextTick()","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"从进程和线程了解浏览器的工作原理","date":"2018-06-14T16:00:00.000Z","path":"2018/06/15/how-does-browser-work/","text":"进程和线程进程（process）和线程（thread）是操作系统的基本概念。 现代操作系统都是可以同时运行多个任务的，比如：用浏览器上网的同时还可以听音乐。对于操作系统来说，一个任务就是一个进程，比如打开一个浏览器就是启动了一个浏览器进程，打开一个 Word 就启动了一个 Word 进程。 有些进程同时不止做一件事，比如 Word，它同时可以进行打字、拼写检查、打印等事情。在一个进程内部，要同时做多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程。 由于每个进程至少要做一件事，所以一个进程至少有一个线程。 系统会给每个进程分配独立的内存，因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段，数据集，堆等）。 如果电脑是 windows 系统，打开任务管理器，可以看到有一个后台进程列表，在这里我们可以看到每个进程的内存资源信息以及 CPU 占有率。 我们再用官方的术语描述一下： 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。 浏览器是多进程的理解了进程和线程之后，接下来我们对浏览器进行一定程度上的认识。 浏览器是多进程的，每打开一个 tab 页，就相当于创建了一个独立的浏览器进程。 图中打开了 Chrome 浏览器的多个 tab 页，在 Chrome 任务管理器中可以看到有多个进程，每一个 tab 页有一个独立的进程。 注意：浏览器应该也有自己的优化机制，有时候打开多个 tab 页，在 Chrome 任务管理器中会看到有些进程被合并了，所以每个 tab 页对应一个进程并不一定是绝对的。 浏览器包含哪些进程？为了简化理解，这里仅列举主要进程。 Browser 进程：浏览器的主进程，只有一个。 负责浏览器界面的显示与交互； 各个页面的管理，创建和销毁其他进程； 网络的资源管理、下载等。 Renderer 进程：也称为浏览器渲染进程或浏览器内核，内部是多线程的。主要负责页面渲染，脚本执行，事件处理等。 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。 GPU 进程：最多一个，用于 3D 绘制等。 浏览器多进程的优势 由于默认 新开 一个 tab 页面 新建 一个进程，所以单个 tab 页面崩溃不会影响到整个浏览器； 同样，第三方插件崩溃也不会影响到整个浏览器； 多进程可以充分利用现代 CPU 多核的优势； 方便使用沙盒模型隔离插件等进程，提高浏览器的稳定性。 系统为浏览器新开的进程分配内存、CPU 等资源，所以内存和 CPU 的资源消耗也会更大。 浏览器内核（渲染进程）前面说了这么多的进程，对普通前端操作来说，最重要的还是渲染进程。 浏览器的渲染进程是多线程的，页面的渲染，JS的执行，事件的循环等，都在这个进程内执行。 渲染进程通常由以下常驻线程组成： 1. GUI 渲染线程负责渲染浏览器界面，解析 HTML、CSS，构建 DOM tree和 render tree，布局和绘制等。当界面需要重绘（repaint）或由于某种操作引发回流（reflow）时，该线程就会执行。 2. JS 引擎线程也称为 JS 内核，负责解析 JavaScript 脚本，运行代码。 JavaScript 是单线程的。 JavaScript 为什么是单线程的？这与它的用途有关。JavaScript 作为浏览器脚本语言，主要用途是与用户互动以及操作 DOM。这也决定了它只能是单线程的，否则会带来很复杂的同步问题。想想一下，如果 JavaScript 同时有连个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个 DOM 节点，这时浏览器应该以哪个线程为准呢？所以，为了避免复杂性，JavaScript 从一开始就是单线程。 GUI 渲染线程 与 JS 引擎线程是互斥的。 由于 JavaScript 可以操作 DOM，如果在修改元素属性的同时渲染界面（即 JavaScript 引擎线程和 GUI 渲染线程同时运行），那么渲染线程前后获得的元素数据就可能会不一致。因此，为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系。当 JS 引擎执行时，GUI 线程被挂起，GUI 更新被保存在一个队列中，等到 JS 引擎线程空闲时立即被执行。 JS 阻塞页面加载。 由于 GUI 渲染线程与 JS 引擎线程是互斥的，当浏览器在执行 JavaScript 的时候，GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成，才会接着执行。因此如果 JS 执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 3. 事件触发线程当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎处理。这些事件可以是当前执行的代码块，如定时任务；也可以是来自浏览器内核的其他线程，如：鼠标点击、Ajax异步请求等。但由于 JS 是单线程的，这些事件都需要排队等待 JS 引擎处理。 4. 定时触发器线程setTimeout 和 setInterval 所在的线程。浏览器定时计数器并不是由 JS 引擎计数的，因为 JS 是单线程的，如果处于阻塞线程状态就会影响计时的准确，所以通过单独的线程来计时并触发定时更为合理。 5. 异步 http 请求线程XMLHttpRequest 在建立连接后，通过浏览器新开一个线程请求，一旦检测到状态变更并且设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，等待 JS 引擎空闲时处理。 Browser 进程和 Renderer 进程的通信过程打开浏览器的一个 tab 页时，我们看下其中的大致过程： Browser 进程收到用户请求，通过网络下载获取页面内容，然后将该任务通过RendererHost接口传递给 Renderer 进程； Renderer 进程的 Renderer 接口收到消息，简单解释后，交给 GUI 渲染线程开始渲染； GUI 渲染线程接收请求，加载网页并渲染网页，这个过程中可能需要 Browser 进程获取资源和 GPU 进程来帮助渲染，也可能会有 JS 引擎线程操作 DOM（可能造成回流并重绘）； 最后 Renderer 进程将结果传递给 Browser 进程； Browser 进程接收到结果，并将结果绘制出来。 到这里应该对浏览器的运作有一定理解了，我们再来看下浏览器是怎么渲染页面的。 浏览器的渲染流程浏览器内核拿到页面内容后，渲染过程大概分为以下几个部分： 解析 HTML 文件，生成 DOM tree；同时解析 CSS 文件以及样式元素中的样式数据，生成 CSS Rules。 构建 render tree：根据 DOM tree 和 CSS Rules 来构建 render tree，它可以让浏览器按照正确的顺序绘制内容。 布局（layout / reflow）：计算各元素尺寸、位置。 绘制（paint）：绘制页面像素信息。 浏览器将各层信息发送给 GPU，GPU 将各层信息合成（composite），显示在屏幕上。 补充： Webkit 将 render tree 中的元素称为 render object （或 renderer），每一个 render object 都代表一个的矩形区域，通常对应于相关节点的 CSS 框，这些矩形的排列顺序就是它们在屏幕上显示的顺序。 Render object 和 DOM 节点是相对应的，但并非一一对应。非可视化的 DOM 元素不会插入 render tree 中，例如“head”元素 和 一些 display: none 的节点就没必要放在 render tree 中了。 这里只是大致的过程，详细步骤可以看参考文章中的第一篇。 渲染完成后，接下来就是 JavaScript 逻辑处理了。 参考资料 浏览器的工作原理：新式网络浏览器幕后揭秘 从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"JavaScript：事件对象","date":"2017-03-30T16:00:00.000Z","path":"2017/03/31/JavaScript：事件对象/","text":"&emsp;&emsp;在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。&emsp;&emsp;所有浏览器都支持 event 对象，但支持方式不同。 DOM中的事件对象&emsp;&emsp;兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级），都会传入 event 对象。 var btn = document.getElementById(&#39;myBtn&#39;); btn.onclick = function(event) { alert(event.type); // click }; btn.addEventListener(&#39;click&#39;, function(event) { alert(event.type); // click }, false); &emsp;&emsp;在通过 HTML 特性指定事件处理程序时，变量 event 中保存着 event 对象。 &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;/&gt; &emsp;&emsp;event 对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都会有下表列出的成员。 属性/方法 类 型 读/写 说明 bubbles Boolean 只读 表明事件是否冒泡 cancelable Boolean 只读 表明是否可以取消事件的默认行为 currentTarget Element 只读 其事件处理程序当前正在处理事件的那个元素 defaultPrevented Boolean 只读 为 true表示已经调用了preventDefault()（DOM3级事件中新增） detail Integer 只读 与事件相关的细节信息 eventPhase Integer 只读 调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段 preventDefault() Function 只读 取消事件的默认行为。如果 cancelable 是 true，则可以使用这个方法 stopImmediatePropagation() Function 只读 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3 级事件中新增） stopPropagation() Function 只读 取消事件的进一步捕获或冒泡。如果 bubbles 为 true，则可以使用这个方法 target Element 只读 事件的目标 trusted Boolean 只读 为true表示事件是浏览器生成的。为 false 表示事件是由开发人员通过JavaScript创建的（DOM3级事件中新增） type String 只读 被触发的事件的类型 view AbstractView 只读 与事件关联的抽象视图。等同于发生事件的 window 对象 在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 this，currentTarget 和 target 包含相同的值。 var btn = document.getElementById(&#39;myBtn&#39;); btn.onclick = function(event) { alert(event.currentTarget === this); // true alert(event.target === this); // true }; 如果事件处理程序存在于按钮的父节点中（例如 document.body），那么这些值是不相同的。 document.body.onclick = function(event) { alert(event.currentTarget === document.body); // true alert(this === document.body); // true alert(event.target === document.getElementById(&#39;myBtn&#39;)); // 点击&#39;myBtn&#39;，结果为true；点击body,结果为false }; 注：只有在事件处理程序执行期间， event 对象才会存在；一旦事件处理程序执行完成， event 对象就会被销毁。 IE中的事件对象&emsp;&emsp;与访问 DOM 中的 event 对象不同，要访问 IE 中的 event 对象有几种不同的方式，取决于指定事件处理程序的方法。 在使用 DOM0 级方法添加事件处理程序时， event 对象作为 window 对象的一个属性存在。var btn = document.getElementById(&#39;myBtn&#39;); btn.onclick = function() { var event = window.event; alert(event.type); // click }; 在使用 DOM2级方法 添加事件处理程序时， event 对象作为参数被传入事件处理程序函数中。var btn = document.getElementById(&#39;myBtn&#39;); btn.attachEvent(&#39;onclick&#39;, function(event) { alert(event.type); // click }); 在 HTML特性 指定的事件处理程序中，通过 event 变量来访问 event对象（与 DOM中的事件模型相同）。&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; &emsp;&emsp;IE 的 event 对象同样也包含与创建它的事件相关的属性和方法。其中很多属性和方法都有对应的或者相关的 DOM属性和方法。所有事件对象都会包含下表所列的属性和方法： 属性/方法 类 型 读/写 说明 cancelBubble Boolean 读/写 默认值为 false，但将其设置为 true，就可以取消事件冒泡（与DOM中的 stopPropagation() 方法的作用相同） returnValue Boolean 读/写 默认值为 true，但将其设置为 false，就可以取消事件的默认行为（与DOM中的 preventDefault() 方法的作用相同），但没有办法确定事件是否能被取消 srcElement Element 只读 事件的目标（与DOM中的 target 属性相同） type String 只读 被触发的事件的类型 跨浏览器的事件对象var EventUtil = { getEvent: function(event) { return event ? event : window.event; }, getTarget: function(event) { return event.target || event.srcElement; }, preventDefault: function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, stopPropagation: function(event) { if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } }, addHandler: function(element, type, handler) { if (element.addEventListener) { element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(&#39;on&#39; + type, handler); } else { element[&#39;on&#39; + type] = handler; } }, removeHandler: function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(&#39;on&#39; + type, handler); } else { element[&#39;on&#39; + type] = null; } } };","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"JavaScript：事件流 & 事件处理程序","date":"2017-03-29T16:00:00.000Z","path":"2017/03/30/JavaScript：事件流&事件处理程序/","text":"定义：事件：用户或浏览器自身执行的某种动作。事件流：描述的是从页面中接收事件的顺序，也可理解为事件在页面中传播的顺序。事件处理程序：响应某个事件的函数就叫做事件处理程序（或事件侦听器）。 事件流（1）事件冒泡 IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。如下图所示： IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 window 对象。 （2）事件捕获 事件捕获的思想与事件冒泡的思想几乎完全相反，是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。如下图所示： （3）DOM事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段 和 事件冒泡阶段。 首先发生的是事件捕获，为截获事件提供了机会。 然后是实际的目标接收到事件。 最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。 在 DOM 事件流中，实际的目标（ 元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从 document 到 再到 后就停止了。下一个阶段是“处于目标”阶段，于是事件在 上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 IE9,Opera,Firefox,Chrome 和 Safari 都支持 DOM 事件流；IE8 及更早版本不支持 DOM 事件流。 事件处理程序 响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以 “on” 开头，因此click 事件的事件处理程序就是 onclick，load 事件的事件处理程序就是 onload 。为事件指定处理程序的方式有以下几种： （1）HTML事件处理程序&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&#39;Clicked&#39;)&quot; /&gt; 缺点： 存在时差问题：因为用户可能会在HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件，就会引发错误。 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。 HTML 与 JavaScript 代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码。 （2）DOM0级事件处理程序 即将一个函数赋值给一个事件处理程序属性。 var btn = document.getElementById(&#39;myBtn&#39;); btn.onclick = function() { alert(&#39;Clicked&#39;); }; btn.onclick = null; // 删除事件处理程序 优点： 简单 可跨浏览器 （3）DOM2级事件处理程序addEventListener(事件名称, 事件函数, 是否捕获); // 添加事件处理程序 removeEventListener(事件名称, 事件函数, 是否捕获); // 移除事件处理程序 所有 DOM 节点中都包含这两个方法。 优点：可以添加多个事件处理程序。 通过 addEventListener() 添加的事件处理程序只能使用 removeEventListener() 来移除。所以通过 addEventListener() 添加的匿名函数将无法移除。 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。 （4）IE事件处理程序attachEvent(事件名称, 事件函数); // 添加事件处理程序 detachEvent(事件名称, 事件函数); // 移除事件处理程序 由于 IE8 及更早版本只支持事件冒泡，所以通过 attachEvent() 添加的事件处理程序都会被添加到冒泡阶段。 注：例如 添加点击事件，attachEvent() 的第一个参数是 “onclick”，而非 DOM 的 addEventListener() 方法中的 “click” 。 在 IE 中使用 attachEvent() 与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用 attachEvent() 方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window 。 attachEvent() 也可以用来为一个元素添加多个事件处理程序。不过，与 DOM 方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。例如：下面的例子，点击按钮，首先看到的是 “Hello world!”，然后是 “Clicked”。 var btn = document.getElementById(&#39;myBtn&#39;); btn.attachEvent(&#39;onclick&#39;, function() { alert(&#39;Clicked&#39;); }); btn.attachEvent(&#39;onclick&#39;, function() { alert(&#39;Hello world!&#39;); }); （5）跨浏览器的事件处理程序 首先要创建的方法是 addHandler() ，它的职责是视情况分别使用 DOM0 级方法、DOM2 级方法或 IE 方法来添加事件。这个方法属于一个名叫 EventUtil 的对象。 addHandler() 方法接受 3 个参数：要操作的元素、事件名称和事件函数。 var EventUtil = { addHandler: function(element, type, handler) { // 添加事件 if (element.addEventListener) { element.addEventListener(type,handler,false); // 使用DOM2级方法添加事件 } else if (element.attachEvent) { // 使用IE方法添加事件 element.attachEvent(&quot;on&quot;+type,handler); } else { element[&quot;on&quot;+type]=handler; // 使用DOM0级方法添加事件 } }, removeHandler: function(element, type, handler) { // 取消事件 if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(&quot;on&quot;+type,handler); } else { element[&quot;on&quot;+type]=null; } } } 使用 EventUtil 对象 var btn = document.getElementById(&#39;myBtn&#39;); var handler = function() { alert(&#39;Clicked&#39;); }; EventUtil.addHandler(btn, &#39;click&#39;, handler); EventUtil.removeHandler(btn, &#39;click&#39;, handler);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"AJAX的工作原理","date":"2017-02-11T16:00:00.000Z","path":"2017/02/12/how-ajax-works/","text":"什么是 AJAX ？ AJAX = 异步 JavaScript 和 XML &emsp;&emsp;AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用AJAX）如果需要更新内容，必需重载整个网页面。 创建AJAX的过程&emsp;&emsp;XMLHttpRequest 是 AJAX 的基础，用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 (1) 创建 XMLHttpRequest 对象var xmlHttp = new XMLHttpRequest(); // IE7及以上 var xmlHttp = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); // IE5 和 IE6 (2) 打开连接xmlHttp.open(method, url, async); method：请求的类型，GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） 同步：指发出数据后，等接收到响应以后再发送下一个数据包的通讯方式。异步：指发出数据后，不用等待接收到响应，接着发送下一个数据包的通讯方式。 (3) 向服务器发送请求xmlHttp.send(string); GET 请求: xmlHttp.send(); POST 请求: xmlHttp.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;); // 向请求添加HTTP头 xmlHttp.send(&#39;fname=Bill&amp;lname=Gates&#39;); GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： a. 无法使用缓存文件（更新服务器上的文件或数据库）； b. 向服务器发送大量数据（POST 没有数据量限制）； c. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠。 (4) 接收服务器响应当请求被发送到服务器时，我们需要执行一些基于响应的任务。 XMLHttpRequest 对象有三个重要的属性： Onreadystatechange 存储函数（或函数名），每当readyState 属性改变时，就会调用该函数。 readyState 存有XMLHttpRequest 的状态信息，从 0 到 4 发生变化。&emsp;&emsp; 0: 请求未初始化&emsp;&emsp; 1: 服务器连接已建立&emsp;&emsp; 2: 请求已接收&emsp;&emsp; 3: 请求处理中&emsp;&emsp; 4: 请求已完成，且响应已就绪 Status（HTTP状态码）&emsp;&emsp; 1字头：消息。这一类型的状态码，代表请求已被接受，需要继续处理。&emsp;&emsp; 2字头：成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。( 200:’OK’ )&emsp;&emsp; 3字头：重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。( 304:’Not Modified’ )&emsp;&emsp; 4字头：请求错误。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。&emsp;&emsp; 5、6字头：服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生。 每当 readyState 改变时，就会触发 onreadystatechange 事件。在onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当readyState 等于 4 且 status 为 2字头或 304 时，表示响应已就绪： xmlHttp.onreadystatechange = function() { if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status &gt;= 200 &amp;&amp; xmlHttp.status &lt; 300 || xmlhttp.status == 304) { document.getElementById(&quot;myDiv&quot;).innerHTML = xmlHttp.responseText; // responseText 获得字符串形式的响应数据 } } 下面是封装的ajax函数： GET 方式： function ajax(url, success, error) { if (window.XMLHttpRequest) { var oAjax = new XMLHttpRequest(); } else { var oAjax = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); } oAjax.open(&#39;GET&#39;, url, true); oAjax.send(); oAjax.onreadystatechange = function() { if (oAjax.readyState == 4) { if (oAjax.status &gt;= 200 &amp;&amp; oAjax.status &lt; 300 || oAjax.status == 304) { success&amp;&amp;success(oAjax.responseText); // 成功的回调函数 } else { error&amp;&amp;error(oAjax.status); // 失败的回调函 } } }; } POST 方式： function ajax(url, success, error) { if (window.XMLHttpRequest) { var oAjax = new XMLHttpRequest(); }else{ var oAjax = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); } oAjax.open(&#39;POST&#39;, url, true); oAjax.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); oAjax.send(&#39;fname=Bill&amp;lname=Gates&#39;); oAjax.onreadystatechange = function() { if (oAjax.readyState == 4) { if (oAjax.status &gt;=200 &amp;&amp; oAjax.status &lt; 300 || oAjax.status == 304) { success&amp;&amp;success(oAjax.responseText); // 成功的回调函数 } else { error&amp;&amp;error(oAjax.status); // 失败的回调函 } } }; }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zouyang0921.com/tags/JavaScript/"}]},{"title":"CSS清除浮动的方法","date":"2017-02-06T16:00:00.000Z","path":"2017/02/07/CSS清除浮动的方法/","text":"前言摘要： 浮动的元素可以向左或向右移动，直到它的外边缘碰到父容器或另一个浮动元素为止。由于浮动元素不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动元素不存在一样。由于浮动的这种特性，当本属于普通流中的元素浮动之后，父容器内部由于不存在其他普通流元素了，所以表现出高度为0（“高度塌陷”）。但在实际布局中，这并不是我们所希望的，所以需要清除浮动，使父容器表现出正常的高度。 正文引用W3C的例子，news容器没有包围浮动的元素。 .news { background-color: gray; border: 1px solid black; } .news img { float: left; } .news p { float: right; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 清除浮动的方法方法一：设置高度 给浮动元素的父元素设置height值，如 .news { height: **px; } 问题：扩展性不好，只适合固定高度的布局，不推荐使用。 方法二：给浮动元素的父元素添加浮动 给浮动元素的父元素也添加浮动属性可以清除内部浮动，但是这样会使页面中所有元素都加浮动，margin左右auto失效，影响布局，不推荐使用。 方法三：inline-block 清除浮动方法 给浮动元素的父元素设置 display 属性为 inline-block问题：margin 左右 auto 失效 方法四：空标签清除浮动 在浮动元素的末尾添加一个空元素，如 &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 并在 CSS 中添加 .clear { clear: both; } 即可清除浮动。 .news { background-color: gray; border: 1px solid black; } .news img { float: left; } .news p { float: right; } .clear { clear: both; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; 优点：简单，浏览器兼容性好。缺点：需要添加大量无意义的空元素，有违结构与表现的分离，后期不容易维护。 方法五：使用相邻元素 给浮动元素后面的元素添加clear属性，如 .news { background-color: gray; border: 1px solid black; } .news img { float: left; } .news p { float: right; } .clear { clear: both; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;div class=&quot;clear&quot;&gt;xxxxxx(内容)&lt;/div&gt; &lt;/div&gt; 方法六：使用overflow属性 给浮动元素的父元素添加 overflow: hidden; // 或 overflow: auto; 在IE6中还需触发 hasLayout，例如 zoom:1。 .news { background-color: gray; border: 1px solid black; overflow: hidden; zoom: 1; } .news img { float: left; } .news p { float: right; } &lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 优点：简单，代码少，不存在结构和语义化问题。缺点：无法显示需要溢出的内容。 方法七：使用 :after 伪元素 需要注意的是 :after 是伪元素（代表一个元素之后最近的元素），不是伪类。给浮动元素的父元素添加一个 class，然后给这个 class 添加一个 :after 伪元素实现元素末尾添加一个看不见的块元素来清除浮动。由于 IE6-7 不支持 :after，需要使用 zoom:1 触发 hasLayout。 .news { background-color: gray; border: 1px solid black; } .news img { float: left; } .news p { float: right; } .clearfix:after { content: &quot;.&quot;; //生成内容作为最后一个元素，点可以换为其他（如:一个看不见的空格&quot;020&quot;） display: block; //使生成的元素以块级元素显示,占满剩余空间; height: 0; //避免生成内容破坏原有布局的高度 visibility: hidden; //使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互 clear: both; } .clearfix { zoom: 1; //触发 hasLayout } &lt;div class=&quot;news clearfix&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;/div&gt; 优点：结构和语义化完全正确，代码量适中，可重复利用（建议定义公共类），推荐使用。缺点：复用方式不当会造成代码量增加。 总结通过以上方法，我们不难发现清除浮动的方法可以分为两类： 一是在浮动元素的末尾添加一个空元素，并设置 clear 属性值为 both，其实 :after 伪元素也是在浮动元素的后面添加了内容为一个点的块元素； 二是通过设置父元素 overflow 属性来清除浮动。 在网页主要布局中通常使用 :after 伪元素来清除浮动，在一些小的模块中使用 overflow:hidden 来清除浮动。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://zouyang0921.com/tags/CSS/"}]}]